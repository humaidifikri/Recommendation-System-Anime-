# -*- coding: utf-8 -*-
"""Anime Recommendation System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UgUGBgJ7W5IqCVkh8WPpY4ii9tsL2MYS

### Import Library
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import nltk
import re
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_distances
from nltk.tokenize import word_tokenize

nltk.download('punkt')

"""### Data Loading"""

df_anime = pd.read_csv('anime.csv')
df_anime.head()

"""### Data Preparation

Melihat info, ukuran, dan ringkasan singkat mengenai dataset
"""

df_anime.info()

# Ukuran dataset
df_anime.shape

# Ringkasan dataset
df_anime.describe()

"""Melihat missing value dan data duplikat yang ada di dataset dan menghapusnya jka ada"""

print(f"Jumlah missing value pada dataframe anime: \n{df_anime.isna().sum()}")

df_anime.dropna(inplace=True)
print(f"Jumlah missing value pada dataframe anime: \n{df_anime.isna().sum()}")

print(f"Jumlah data duplikat pada dataframe anime: \n{df_anime.duplicated().sum()}")

"""Melihat keragaman data kategorik dari kolom `genre`, `type`, dan `episodes`"""

df_anime['genre'].unique()

df_anime['type'].unique()

df_anime['episodes'].unique()

"""### Data Preprocessing

Melihat berapa banyak data 'Unknown' dari kolom episodes
"""

df_anime[df_anime['episodes'] == 'Unknown']

"""Ternyata cukup banya data 'Unknown' daripada kita hapus lebih baik kita ganti valuenya dengan 'Ongoing' karena lebih masuk akal."""

df_anime.loc[df_anime['episodes'] == 'Unknown', 'episodes'] = 'Ongoing'
df_anime[df_anime['episodes'] == 'Ongoing']

def text_cleaning(text):
    text = re.sub(r'"', '', text)
    text = re.sub(r'.hack//', '', text)
    text = re.sub(r"'", '', text)
    text = re.sub(r"A's", '', text)
    text = re.sub(r"I'", "I\'", text)
    text = re.sub(r'&', 'and', text)
    return text

df_anime['name'] = df_anime['name'].apply(text_cleaning)

"""Fungsi `text_cleaning` ini untuk membersihkan simbol yang ada di kolom `name` dengan menggunakan RegEx (Regular Expression)

##### Univariate Data Analysis

Melihat persebaran distribusi dari kolom `type` dan `rating` dari anime
"""

plt.subplot(2,2,1)
plt.title('Anime Type')
df_anime.type.hist(figsize=(15,10));

plt.subplot(2,2,2)
plt.title('Anime Rating')
df_anime.rating.hist(figsize=(15,10));

"""Setelah kita melakukan visualisasi, kita tahu bahwa kebanyakan anime bertipe TV dan OVA dengan kebanyakan anime mendapatkan rating sekitar 6 - 7

### Modeling  
Tahap ini kita membuat fungsi untuk mendapatkan untuk rekomendasi berdasarkan anime serupa.

#### Content Based Filtering

Inisialisasi CountVectorizer pada variabel `bow` (Bag of Words) dan variabel `bank` berisi representasi bag-of-words dari teks dalam kolom genre
"""

# Inisialisasi CountVectorizer
bow = CountVectorizer(stop_words="english",tokenizer=word_tokenize)

# Menerapkan CountVectorizer pada kolom 'genre' dari df_anime
bank = bow.fit_transform(df_anime['genre'])

"""Variabel `idx` akan digunakan sebagai indeks baris dan variabel `content` mengakses nilai pada baris dengan indeks idx"""

# Indeks baris untuk memilih data dari DataFrame df_anime
idx = 0

#  Mengakses nilai pada baris dengan indeks idx dan kolom genre
content = df_anime.loc[idx,'genre']
content

"""Variabel `code` menyimpan hasil dari transformasi teks content menjadi representasi bag-of-words (BoW)."""

code = bow.transform([content])
code

"""Menghitung jarak kosinus antara dua matriks sparse `code` dan `bank` lalu menampilkannya"""

dist = cosine_distances(code, bank)
dist

"""Variabel `rec_idx` menyimpan indeks dokumen dengan jarak kosinus terkecil (tidak termasuk dokumen itu sendiri) sebagai rekomendasi dan memilih indeks ke-1 hingga ke-5 dalam urutan tersebut"""

rec_idx = dist.argsort()[0,1:6]
rec_idx

"""Mengakses baris-baris pada DataFrame `df_anime` menggunakan indeks yang disimpan dalam `rec_idx`"""

df_anime.loc[rec_idx,["name", "genre"]]

"""### Membuat Fungsi Model"""

def Recommendation(idx,dataframe,column):
    bow = CountVectorizer(stop_words="english",tokenizer=word_tokenize)
    bank = bow.fit_transform(dataframe[column])
    content = dataframe.loc[idx,column]
    code = bow.transform([content])
    dist = cosine_distances(code, bank)
    rec_idx = dist.argsort()[0,1:6]
    print(f"Anime '{dataframe['name'][idx]}' \ndengan genre '{dataframe['genre'][idx]}'\nRekomendasi untuk user: ")
    return df_anime.loc[rec_idx, ["name", "genre"]]

"""- idx: Indeks anime yang akan digunakan sebagai referensi untuk rekomendasi.
- dataframe: DataFrame yang berisi data anime.
- column: Nama kolom yang berisi genre yang akan digunakan untuk perhitungan kesamaan.

Lalu fungsi tersebut mencetak informasi tentang anime referensi dan genrenya dan mengembalikan DataFrame yang berisi nama dan genre anime yang direkomendasikan berdasarkan kesamaan genre.
"""

Recommendation(1,df_anime,'genre')

Recommendation(17,df_anime,'genre')

Recommendation(69,df_anime,'genre')

"""Sistem telah berhasil merekomendasikan top 5 anime yang mirip dengan masing-masing genrenya, yaitu beberapa film dan seri dari anime itu sendiri. Jadi, jika pengguna menyukai Fullmetal Alchemist: Brotherhood, maka sistem dapat merekomendasikan seri atau movie lainnya."""